// concept for html5 graphics rendering
/*
on level start:
create divs for each wall
create divs for players
move divs as players move
on level change: delete container to clear screen

*/

console.log('Do not paste anything here unless you know what you are doing! You may be giving hackers access to your data!');

// code snippet to disable arrow key scrolling from https://stackoverflow.com/a/8916697
window.addEventListener("keydown", function(e) {
	if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
		e.preventDefault();
	}
}, false);

var Levels,
	player = {
		level: 0,
		name: 'Unknown',
		uid: undefined,
		w: undefined,
		h: undefined,
		x: undefined,
		y: undefined
	};
let xhttp = new XMLHttpRequest();
xhttp.open('GET', 'levels.json', true);
xhttp.onreadystatechange = function() {
	if (xhttp.readyState == 4) {
		Levels = JSON.parse(xhttp.response).Levels;
		console.log('Received levels, starting game...');
		new p5(Game, 'game-container');
	}
};
console.log('Requesting levels');
xhttp.send();

const ws = new WebSocket('ws://52.2.197.118:25565');

ws.onclose = function() {
	alert('WebSocket connection closed, this could be due to an error connecting to the server, or the server being down. Refresh the page to retry.');
};

ws.onmessage = function(message) {
	var data = message.data.split('|');
	switch (data[0]) {
// 0: player update, 1: wall update, 2: button state update
		case '0':
			player.level = data[1];
			player.uid = data[2];
			player.name = data[3];
			player.state = data[4];
			player.w = data[5];
			player.h = data[6];
			player.x = data[7];
			player.y = data[8];
			var players = [];
			for (var i=9;i<data.length;i+=7) {
				players.push({
					uid: data[i],
					name: data[i+1],
					state: parseInt(data[i+2]),
					w: parseInt(data[i+3]),
					h: parseInt(data[i+4]),
					x: parseInt(data[i+5]),
					y: parseInt(data[i+6])
				});
			}
			Levels[player.level].players = players;
			break;
		case '1':
			Levels[player.level].walls[data[1]][data[2]] = data[3];
			break;
		case '2':
			Levels[player.level].walls.forEach(function(wall) {
				if (wall[5] == data[1]) {
					wall[6] = data[2];
				}
			});
	}
};

const buttonColors = [[255, 0, 0, 150], [255, 255, 0, 150], [0, 0, 255, 150], [255, 0, 255, 150]];

let Game = function(p) {
	let memo = document.getElementById('memo');
	p.setup = function() {
		p.createCanvas(800, 600);
		p.frameRate(24);
	};
	p.keyPressed = function() {
		ws.send(''+(p.keyIsDown(32)||p.keyIsDown(87)||p.keyIsDown(p.UP_ARROW)?1:0)+(p.keyIsDown(83)||p.keyIsDown(p.DOWN_ARROW)?1:0)+(p.keyIsDown(65)||p.keyIsDown(p.LEFT_ARROW)?1:0)+(p.keyIsDown(68)||p.keyIsDown(p.RIGHT_ARROW)?1:0));
	};
	p.keyReleased = function() {
		ws.send(''+(p.keyIsDown(32)||p.keyIsDown(87)||p.keyIsDown(p.UP_ARROW)?1:0)+(p.keyIsDown(83)||p.keyIsDown(p.DOWN_ARROW)?1:0)+(p.keyIsDown(65)||p.keyIsDown(p.LEFT_ARROW)?1:0)+(p.keyIsDown(68)||p.keyIsDown(p.RIGHT_ARROW)?1:0));
	};
	p.draw = function() {
		p.background(220, 220, 255);
		p.strokeWeight(1);
		p.rectMode(p.CORNERS);
		// draw memo
//		memo.innerHTML = Levels[player.level].memo;
		// draw level
		p.fill(0);
		Levels[player.level].walls.forEach(function(wall) {
			switch (wall[0]) {
				case 0:
					p.fill(0);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 1:
					p.fill(0, 255, 0, 150);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 2:
					p.fill(255, 0, 0, 150);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 3:
					p.fill(buttonColors[wall[5]][0], buttonColors[wall[5]][1], buttonColors[wall[5]][2], 255);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 4:
					p.fill(buttonColors[wall[5]][0], buttonColors[wall[5]][1], buttonColors[wall[5]][2], (wall[6] == '1'?50:buttonColors[wall[5]][3]));
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 5:
					p.fill(255, 165, 0, 255);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				case 6:
					p.fill(50, 50, 50, 255);
					p.rect(wall[1], wall[2], wall[3], wall[4]);
					break;
				default:
					break;
			}
		});
		// draw other players
		p.fill(255);
		Levels[player.level].players.forEach(function(plr) {
			p.rect(parseInt(plr.x), parseInt(plr.y), parseInt(plr.x) + parseInt(plr.w), parseInt(plr.y) + parseInt(plr.h));
		});
		// draw player
		p.fill(0, 255, 0);
		p.rect(parseInt(player.x), parseInt(player.y), parseInt(player.x) + parseInt(player.w), parseInt(player.y) + parseInt(player.h));
	};
};
